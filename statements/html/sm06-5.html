<html>
 <head>
  <meta charset="utf-8"/>
 </head>
 <body>
  <table border="1">
   <tr>
    <td>
     <b>
      Time limit:
     </b>
    </td>
    <td>
     <tt>
      1 s
     </tt>
    </td>
   </tr>
   <tr>
    <td>
     <b>
      Real time limit:
     </b>
    </td>
    <td>
     <tt>
      5 s
     </tt>
    </td>
   </tr>
   <tr>
    <td>
     <b>
      Memory limit:
     </b>
    </td>
    <td>
     <tt>
      64M
     </tt>
    </td>
   </tr>
  </table>
  <h3>
   Problem sm06-5: c/function-pointers/func-poliz-1
  </h3>
  <p>
   Напишите компилятор выражений в польской записи в "шитый" код, то есть в специальное внутреннее представление,
удобное для исполнения, как описано далее.
  </p>
  <p>
   Польская запись передается на вход в виде строки, в которой элементы
польской записи отделяются друг от друга пробельными символами.
Обозначим стек вычислений польской записи через S.
На стеке вычислений хранятся 32-битные знаковые целые числа.
Элемент S[0] — это верхушка стека, S[1] — это следующий
после верхушки элемент на стеке. В польской записи поддерживаются следующие элементы:
  </p>
  <table border="1">
   <tr>
    <td>
     <tt>
      NUM
     </tt>
    </td>
    <td>
     NUM — это 32-битное целое число, перед которым допускается необязательные знаки "плюс" или "минус".
    значение числа помещается в стек.
    </td>
   </tr>
   <tr>
    <td>
     <tt>
      +
     </tt>
    </td>
    <td>
     Вычислить S[1] + S[0]. Оба значения удаляются из стека, результат операции помещается в стек.
    </td>
   </tr>
   <tr>
    <td>
     <tt>
      -
     </tt>
    </td>
    <td>
     Вычислить S[1] - S[0]. Оба значения удаляются из стека, результат операции помещается в стек.
    </td>
   </tr>
   <tr>
    <td>
     <tt>
      *
     </tt>
    </td>
    <td>
     Вычислить S[1] * S[0]. Оба значения удаляются из стека, результат операции помещается в стек.
    </td>
   </tr>
   <tr>
    <td>
     <tt>
      /
     </tt>
    </td>
    <td>
     Вычислить S[1] / S[0] (по математическим правилам нацело). Оба значения удаляются из стека, результат операции помещается в стек.
    </td>
   </tr>
   <tr>
    <td>
     <tt>
      %
     </tt>
    </td>
    <td>
     Вычислить S[1] % S[0] (по математическим правилам). Оба значения удаляются из стека, результат операции помещается в стек.
    </td>
   </tr>
   <tr>
    <td>
     <tt>
      #
     </tt>
    </td>
    <td>
     Вычислить -S[0]. Аргумент операции удаляется из стека, результат операции помещается в стек.
    </td>
   </tr>
   <tr>
    <td>
     <tt>
      r
     </tt>
    </td>
    <td>
     Считать со стандартного потока ввода 32-битное знаковое целое значение в десятичной записи, результат операции помещается в стек.
    </td>
   </tr>
   <tr>
    <td>
     <tt>
      w
     </tt>
    </td>
    <td>
     Вывести на стандартный поток вывода S[0]. Аргумент удаляется из стека.
    </td>
   </tr>
   <tr>
    <td>
     <tt>
      n
     </tt>
    </td>
    <td>
     Вывести на стандартный поток вывода символ \n.
    </td>
   </tr>
   <tr>
    <td>
     <tt>
      ;
     </tt>
    </td>
    <td>
     Удалить элемент из верхушки стека.
    </td>
   </tr>
   <tr>
    <td>
     <tt>
      dNUM
     </tt>
    </td>
    <td>
     Поместить элемент S[NUM] на верхушку стека. Если NUM не указан, подразумевается значение индекса 0.
    Таким образом команда
     <tt>
      d
     </tt>
     копирует элемент на верхушке стека, как и команда
     <tt>
      d0
     </tt>
     .
    Команда
     <tt>
      d1
     </tt>
     заносит на верхушку стека значение S[1], где индекс берется до выполнения операции занесения в стек.
    Индекс NUM всегда неотрицательный.
    </td>
   </tr>
   <tr>
    <td>
     <tt>
      sNUM
     </tt>
    </td>
    <td>
     Обменять местами S[NUM] и S[0]. Если NUM не указан, подразумевается значение индекса 1.
    Таким образом команда
     <tt>
      s
     </tt>
     меняет местами S[1] и S[0], как и команда
     <tt>
      s1
     </tt>
     .
    Команда
     <tt>
      s0
     </tt>
     не делает ничего (даже если стек пуст). Индекс NUM всегда неотрицательный.
    </td>
   </tr>
  </table>
  <p>
   Предопределены следующие типы данных:
  </p>
  <pre>
// opaque structure for poliz calculation state
struct PolizState;

// poliz operation handler
typedef int (*poliz_func_t)(struct PolizState *state, int iextra);

struct PolizItem
{
    poliz_func_t handler;
    int iextra;
};

// runtime errors
enum
{
    PE_OK,  // no error
    PE_STACK_UNDERFLOW, // not enough elements on stack
    PE_INVALID_INDEX, // s or d operations refer to invalid index
    PE_DIVISION_BY_ZERO,
    PE_INT_OVERFLOW,
    PE_READ_FAILED, // read from stdin failed to convert integer for any reason
    PE_OUT_OF_MEMORY,
};

struct PolizItem *poliz_compile(const char *str);

struct PolizState *poliz_new_state(void);
void poliz_free_state(struct PolizState *state);
int poliz_last_error(struct PolizState *state);
</pre>
  <p>
   Функция компиляции должна иметь следующий прототип:
  </p>
  <pre>
struct PolizItem *poliz_compile(const char *str);
</pre>
  <p>
   Функция компиляции возвращает массив элементов польской записи.
Последний элемент массива содержит указатель handler равный NULL.
Массив должен выделяться в динамической памяти.
  </p>
  <p>
   Если дана строка
   <tt>
    str
   </tt>
   , то вычисление значения
выполняется следующим образом:
  </p>
  <pre>
    struct PolizItem *items = poliz_compile(str);
    struct PolizState *state = poliz_new_state();
    for (int i = 0; items[i].handler != NULL; ) {
        int err = items[i].handler(state, items[i].iextra);
        if (err &lt; 0) {
            fprintf(stderr, "error: %d\n", -err);
            break;
        } else if (err &gt; 0) {
            i = err;
        } else {
            ++i;
        }
    }
    poliz_free_state(state);
    free(items);
</pre>
  <p>
   <b>
    Ваша задача
   </b>
   : написать функции
   <tt>
    poliz_compile
   </tt>
   ,
   <tt>
    poliz_new_state
   </tt>
   ,
   <tt>
    poliz_free_state
   </tt>
   ,
   <tt>
    poliz_last_error
   </tt>
   и функции-обработчики команд польской записи.
   <b>
    Не сдавайте
   </b>
   код функции
   <tt>
    main
   </tt>
   . Вам будет доступен заголовочный файл
   <a href="https://caos.ejudge.ru/ej/client?SID=00000000&amp;prob_id=37&amp;action=194&amp;file=poliz.h">
    <tt>
     poliz.h
    </tt>
   </a>
   ,
который вы можете включать директивой #include.
  </p>
  <p>
   Функция
   <tt>
    poliz_last_error
   </tt>
   возвращает код последней ошибки при выполнении польской записи.
Если в процессе выполнения произошла ошибка, но выполнение не было прервано, то
все последующие после ошибки команды ничего не делают, то есть
в начале каждого обработчика команды должна находиться проверка:
  </p>
  <pre>
    // проверяем была ли ошибка ранее
    if (state-&gt;err) return -state-&gt;err;
</pre>
  <p>
   Используйте ключевое слово
   <tt>
    static
   </tt>
   там, где это полезно.
  </p>
  <p>
   Можете предполагать, что польская запись корректна, за исключением возможных ошибок времени выполнения.
То есть, польская запись может содержать ошибку деления на константу 0, но выявлять ее при компиляции,
как и выявлять антипереполнение и другие ошибки времени выполнения не нужно.
  </p>
  <p>
   Например, если дана строка
   <tt>
    r r + w n
   </tt>
   , при чтении со стандартного потока ввода
  </p>
  <pre>
  100 128
</pre>
  <p>
   на стандартный поток вывода должно быть напечатано
  </p>
  <pre>228
</pre>
  <p>
   Обратите внимание, что длина вывода должна быть в точности 4 символа (3 цифры и \n).
  </p>
 </body>
</html>