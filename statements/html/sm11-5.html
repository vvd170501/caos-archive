<html><head><meta charset="utf-8"/></head>
<body>
<table border="1"><tr><td><b>Time limit:</b></td><td><tt>1 s</tt></td></tr>
<tr><td><b>Real time limit:</b></td><td><tt>5 s</tt></td></tr>
<tr><td><b>Memory limit:</b></td><td><tt>64M</tt></td></tr>
</table>
<h3>Problem sm11-5: c/binary-files/binary-reverse-3</h3>
<p>В аргументах командной строки передается имя бинарного файла произвольного доступа и 32-битное знаковое целое число A.
Бинарный файл содержит структуры Data, описанные ниже.
</p>
<pre>struct Data
{
    int16_t x; // 2 байта,
    int64_t y; // 8 байт
};</pre>
<p>Размер каждой структуры в файле - 10 байт, структуры в файле располагаются подряд.</p>
<p>Числа хранятся в представлении Little-Endian. Ваша программа должна корректно работать на платформах с любым порядком байт.</p>
<p>Преобразуйте файл следующим образом:</p>
<ul>
<li>Измените порядок следования структур на противоположный, то есть первый элемент
становится последним, второй - предпоследним и т. д.
</li>
<li>Для каждой структуры модифицируйте значение поля y следующим образом: y += x * A. В случае арифметического переполнения выводите сообщение об ошибке и завершайте работу с кодом 3.
</li>
</ul>
<p>Хранить в памяти более двух структур не разрешается.
Для ввода-вывода в файле использовать низкоуровневые средства.
</p>
<p>Напишите функции <tt>marshall</tt> и <tt>unmarshall</tt>,
которые преобразовывают данные перед записью в файл.
Функции имеют следующие прототипы:</p>
<pre>
void marshall(unsigned char *out, const struct Data *in);
void unmarshall(struct Data *out, const unsigned char *in);
</pre>
<p>Функция <tt>marshall</tt> преобразовывает данные,
хранящиеся в структуре в параметре <tt>in</tt> в локальном
представлении данных, в буфер требуемого размера, подготовленный для
записи в файл.
Функция <tt>unmarshall</tt> выполняет обратные действия.</p>
<p>Контролируйте корректность операций чтения и записи. В случае ошибки выведите сообщение об ошибке и завершите работу с кодом 2.</p>
</body></html>