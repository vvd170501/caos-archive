<html>
 <head>
  <meta charset="utf-8"/>
 </head>
 <body>
  <table border="1">
   <tr>
    <td>
     <b>
      Time limit:
     </b>
    </td>
    <td>
     <tt>
      1 s
     </tt>
    </td>
   </tr>
   <tr>
    <td>
     <b>
      Real time limit:
     </b>
    </td>
    <td>
     <tt>
      5 s
     </tt>
    </td>
   </tr>
   <tr>
    <td>
     <b>
      Memory limit:
     </b>
    </td>
    <td>
     <tt>
      64M
     </tt>
    </td>
   </tr>
  </table>
  <h3>
   Problem sm10-3: unix/files/nextchar-2
  </h3>
  <p>
   Опишите структуру
   <tt>
    FileReadState
   </tt>
   для хранения состояния буферизованного ввода из файла. Структура
может быть описана примерно так:
  </p>
  <pre>struct FileReadState
{
    int fd;              // "файловый дескриптор", для чтения со стандартного потока ввода - 0
    unsigned char *buf;  // указатель на буфер
    int bufsize;         // размер буфера
    int lc;              // последний считанный символ
    // здесь потребуется добавить поля для реализации буферизованного чтения
};</pre>
  <p>
   Определите глобальную переменную:
  </p>
  <pre>struct FileReadState *stin;</pre>
  <p>
   В вашей реализации переменная
   <tt>
    stin
   </tt>
   должна быть уже инициализирована корректным указателем
на корректную структуру состояния чтения при запуске программы (то есть используйте инициализацию
глобальных переменных). Буфер должен быть выделен статически, его размер должен быть равен 4KiB.
  </p>
  <p>
   Напишите функцию
   <tt>
    nextchar
   </tt>
   на Си, выполняющую буферизованное чтение
одного символа со стандартного потока ввода. Функция
   <tt>
    nextchar
   </tt>
   не принимает аргументов, но работает с глобальной переменной
   <tt>
    stin
   </tt>
   .
Функция возвращает считанный со стандартного потока ввода символ - целое число
в интервале [0; 255], а после достижения конца файла подпрограмма возвращает -1.
Кроме того, результат записывается в поле
   <tt>
    lc
   </tt>
   структуры.
  </p>
  <p>
   Буферизация ввода выполняется следующим образом.
Чтение со стандартного потока ввода выполняется не побайтово, а блоками. За один системный вызов
   <tt>
    read
   </tt>
   подпрограмма пытается заполнить внутренний буфер
   <tt>
    buf
   </tt>
   размера
   <tt>
    bufsize
   </tt>
   . При этом нормально, что
   <tt>
    read
   </tt>
   может
считать меньшее количество данных. Подпрограмма
   <tt>
    nextchar
   </tt>
   затем возвращает по одному байту из буфера в памяти.
Когда будет считано все содержимое буфера, буфер заполняется снова.
Когда при чтении со стандартного потока ввода
   <tt>
    read
   </tt>
   возвращает значение &lt;= 0, устанавливается флаг
конца файла и все дальнейшие вызовы
   <tt>
    nextchar
   </tt>
   возвращают значение -1.
  </p>
  <p>
   Напишите функцию
   <tt>
    lastchar
   </tt>
   , которая возвращает последний считанный символ, то есть значение поля
   <tt>
    lc
   </tt>
   .
Если до вызова
   <tt>
    lastchar
   </tt>
   не было вызова
   <tt>
    nextchar
   </tt>
   — поведение неопределено (т. е. делайте что хотите).
  </p>
  <p>
   Функции должны быть написаны на Си, но при этом вам не будет доступна стандартная библиотека Си, включая функцию
   <tt>
    read
   </tt>
   (программа будет компилироваться с флагом -nostdlib). Для выполнения системного вызова чтения используйте встроенный в gcc ассемблер
(ключевое слово asm).
  </p>
 </body>
</html>