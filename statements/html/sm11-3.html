<html><head><meta charset="utf-8"/></head>
<body>
<table border="1"><tr><td><b>Time limit:</b></td><td><tt>2 s</tt></td></tr>
<tr><td><b>Real time limit:</b></td><td><tt>5 s</tt></td></tr>
<tr><td><b>Memory limit:</b></td><td><tt>64M</tt></td></tr>
</table>
<h3>Problem sm11-3: unix/files/read-file-fd-1</h3>
<p>Напишите функцию</p>
<pre>
struct FileContent
{
    ssize_t size;
    char *data;
};
struct FileContent read_file(int fd);</pre>
<p>Функция должна считать все содержимое файла по переданному файловому дескриптору.
В случае ошибки чтения поле <tt>size</tt> должно быть равно -1, а поле <tt>data</tt> — NULL.
В случае успешного чтения поле <tt>size</tt> должно содержать размер считанного файла,
поле <tt>data</tt> — указатель на считанные данные. Область памяти <tt>data</tt>
должна быть на 1 больше размера файла, и последний байт в области должен содержать
байт 0. Таким образом, текстовый файл в памяти будет хранится как строка (null-terminated string).</p>
<p>Ситуация нехватки памяти должна обрабатываться. В этом случае возвращаемое значение
такое же, как при ошибке чтения.</p>
<p>Для буферизации ввода используйте локальный буфер размера 4096 байт.</p>
<p>Используйте POSIX API работы с файлами.</p>
<p>Помните, что <tt>read</tt> не обязан всегда считывать ровно то количество байт,
которое было запрошено.</p>
<p>При сдаче программы структура FileContent будет уже определена.
Не определяйте ее в сдаваемом на проверку коде.</p>
</body></html>